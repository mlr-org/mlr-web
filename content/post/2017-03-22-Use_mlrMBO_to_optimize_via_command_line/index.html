---
title: "Use mlrMBO to optimize via command line"
authors: ["jakob-richter"]
date: 2017-03-22
categories: ["R", "r-bloggers"]
tags: ["mlrMBO", "command-line", "rstats"]
---



<p>Many people who want to apply Bayesian optimization want to use it to optimize an algorithm that is not implemented in <strong>R</strong> but runs on the command line as a shell script or an executable.</p>
<p>We recently published <a href="https://mlrMBO.mlr-org.com/"><strong>mlrMBO</strong></a> on CRAN.
As a normal package it normally operates inside of R, but with this post I want to demonstrate how <strong>mlrMBO</strong> can be used to optimize an external application.
At the same time I will highlight some issues you can likely run into.</p>
<p>First of all we need a bash script that we want to optimize.
This tutorial will only run on Unix systems (Linux, OSX etc.) but should also be informative for windows users.
The following code will write a tiny bash script that uses <code>bc</code> to calculate <span class="math inline">\(sin(x_1-1) + (x_1^2 + x_2^2)\)</span> and write the result “hidden” in a sentence (<code>The result is 12.34!</code>) in a <code>result.txt</code> text file.</p>
<div id="the-bash-script" class="section level3">
<h3>The bash script</h3>
<pre class="r"><code># write bash script
lines = &#39;#!/bin/bash
fun ()
{
  x1=$1
  x2=$2
  command=&quot;(s($x1-1) + ($x1^2 + $x2^2))&quot;
  result=$(bc -l &lt;&lt;&lt; $command)
}
echo &quot;Start calculation.&quot;
fun $1 $2
echo &quot;The result is $result!&quot; &gt; &quot;result.txt&quot;
echo &quot;Finish calculation.&quot;
&#39;
writeLines(lines, &quot;fun.sh&quot;)
# make it executable:
system(&quot;chmod +x fun.sh&quot;)</code></pre>
</div>
<div id="running-the-script-from-r" class="section level3">
<h3>Running the script from R</h3>
<p>Now we need a R function that starts the script, reads the result from the text file and returns it.</p>
<pre class="r"><code>library(stringi)
runScript = function(x) {
  command = sprintf(&quot;./fun.sh %f %f&quot;, x[[&#39;x1&#39;]], x[[&#39;x2&#39;]])
  error.code = system(command)
  if (error.code != 0) {
    stop(&quot;Simulation had error.code != 0!&quot;)
  }
  result = readLines(&quot;result.txt&quot;)
  # the pattern matches 12 as well as 12.34 and .34
  # the ?: makes the decimals a non-capturing group.
  result = stri_match_first_regex(result, 
    pattern = &quot;\\d*(?:\\.\\d+)?(?=\\!)&quot;)
  as.numeric(result)
}</code></pre>
<p>This function uses <code>stringi</code> and <em>regular expressions</em> to match the result within the sentence.
Depending on the output different strategies to read the result make sense.
XML files can usually be accessed with <code>XML::xmlParse</code>, <code>XML::getNodeSet</code>, <code>XML::xmlAttrs</code> etc. using <code>XPath</code> queries.
Sometimes the good old <code>read.table()</code> is also sufficient.
If, for example, the output is written in a file like this:</p>
<pre class="r"><code>value1 = 23.45
value2 = 13.82</code></pre>
<p>You can easily use <code>source()</code> like that:</p>
<pre class="r"><code>EV = new.env()
eval(expr = {a = 1}, envir = EV)
as.list(EV)
source(file = &quot;result.txt&quot;, local = EV)
res = as.list(EV)
rm(EV)</code></pre>
<p>which will return a list with the entries <code>$value1</code> and <code>$value2</code>.</p>
</div>
<div id="define-bounds-wrap-function." class="section level3">
<h3>Define bounds, wrap function.</h3>
<p>To evaluate the function from within <strong>mlrMBO</strong> it has to be wrapped in <strong>smoof</strong> function.
The smoof function also contains information about the bounds and scales of the domain of the objective function defined in a <em>ParameterSet</em>.</p>
<pre class="r"><code>library(mlrMBO)
## Loading required package: mlr
## Loading required package: ParamHelpers
## Loading required package: smoof
## Loading required package: BBmisc
## 
## Attaching package: &#39;BBmisc&#39;
## The following object is masked from &#39;package:base&#39;:
## 
##     isFALSE
## Loading required package: checkmate
# Defining the bounds of the parameters:
par.set = makeParamSet(
  makeNumericParam(&quot;x1&quot;, lower = -3, upper = 3),
  makeNumericParam(&quot;x2&quot;, lower = -2.5, upper = 2.5)
)
# Wrapping everything in a smoof function:
fn = makeSingleObjectiveFunction(
  id = &quot;fun.sh&quot;, 
  fn = runScript,
  par.set = par.set,
  has.simple.signature = FALSE
)

# let&#39;s see if the function is working
des = generateGridDesign(par.set, resolution = 3)
des$y = apply(des, 1, fn)
des
##   x1   x2         y
## 1 -3 -2.5 16.006802
## 2  0 -2.5  5.408529
## 3  3 -2.5 16.159297
## 4 -3  0.0  9.756802
## 5  0  0.0  0.841471
## 6  3  0.0  9.909297
## 7 -3  2.5 16.006802
## 8  0  2.5  5.408529
## 9  3  2.5 16.159297</code></pre>
<p>If you run this locally, you will see that the console output generated by our shell script directly appears in the R-console.
This can be helpful but also annoying.</p>
</div>
<div id="redirecting-output" class="section level3">
<h3>Redirecting output</h3>
<p>If a lot of output is generated during a single call of <code>system()</code> it might even crash R.
To avoid that I suggest to redirect the output into a file.
This way no output is lost and the R console does not get flooded.
We can simply achieve that by replacing the <code>command</code> in the function <code>runScript</code> from above with the following code:</p>
<pre class="r"><code>  # console output file output_1490030005_1.1_2.4.txt
  output_file = sprintf(&quot;output_%i_%.1f_%.1f.txt&quot;, 
    as.integer(Sys.time()), x[[&#39;x1&#39;]], x[[&#39;x2&#39;]])
  # redirect output with ./fun.sh 1.1 2.4 &gt; output.txt
  # alternative: ./fun.sh 1.1 2.4 &gt; /dev/null to drop it
  command = sprintf(&quot;./fun.sh %f %f &gt; %s&quot;, x[[&#39;x1&#39;]], x[[&#39;x2&#39;]], output_file)</code></pre>
</div>
<div id="start-the-optimization" class="section level3">
<h3>Start the Optimization</h3>
<p>Now everything is set so we can proceed with the usual MBO setup:</p>
<pre class="r"><code>ctrl = makeMBOControl()
ctrl = setMBOControlInfill(ctrl, crit = crit.ei)
ctrl = setMBOControlTermination(ctrl, iters = 10)
configureMlr(show.info = FALSE, show.learner.output = FALSE)
run = mbo(fun = fn, control = ctrl)
## Computing y column(s) for design. Not provided.
## [mbo] 0: x1=-1.28; x2=1.97 : y = 4.77 : 0.0 secs : initdesign
## [mbo] 0: x1=1.23; x2=0.35 : y = 1.87 : 0.0 secs : initdesign
## [mbo] 0: x1=-2.42; x2=0.984 : y = 7.08 : 0.0 secs : initdesign
## [mbo] 0: x1=2.3; x2=-0.95 : y = 7.16 : 0.0 secs : initdesign
## [mbo] 0: x1=-0.6; x2=-1.41 : y = 1.34 : 0.0 secs : initdesign
## [mbo] 0: x1=-1.57; x2=-0.204 : y = 1.96 : 0.0 secs : initdesign
## [mbo] 0: x1=0.596; x2=1.84 : y = 3.36 : 0.0 secs : initdesign
## [mbo] 0: x1=1.83; x2=-2.41 : y = 9.86 : 0.0 secs : initdesign
## [mbo] 1: x1=-0.432; x2=-0.246 : y = 0.743 : 0.0 secs : infill_ei
## [mbo] 2: x1=-0.895; x2=-0.713 : y = 0.362 : 0.0 secs : infill_ei
## [mbo] 3: x1=0.217; x2=-0.519 : y = 0.389 : 0.0 secs : infill_ei
## [mbo] 4: x1=-0.134; x2=-0.669 : y = 0.441 : 0.0 secs : infill_ei
## [mbo] 5: x1=0.242; x2=0.14 : y = 0.609 : 0.0 secs : infill_ei
## [mbo] 6: x1=-1.09; x2=-0.902 : y = 1.13 : 0.0 secs : infill_ei
## [mbo] 7: x1=-0.736; x2=-0.605 : y = 0.078 : 0.0 secs : infill_ei
## [mbo] 8: x1=-0.645; x2=-0.653 : y = 0.155 : 0.0 secs : infill_ei
## [mbo] 9: x1=3; x2=2.5 : y = 16.1 : 0.0 secs : infill_ei
## [mbo] 10: x1=0.65; x2=-0.576 : y = 0.411 : 0.0 secs : infill_ei
# The resulting optimal configuration:
run$x
## $x1
## [1] -0.7364951
## 
## $x2
## [1] -0.6048879
# The best reached value:
run$y
## [1] 0.07798898</code></pre>
</div>
<div id="execute-the-r-script-from-a-shell" class="section level3">
<h3>Execute the R script from a shell</h3>
<p>Also you might not want to bothered having to start <em>R</em> and run this script manually so what I would recommend is saving all above as an R-script plus some lines that write the output in a JSON file like this:</p>
<pre class="r"><code>library(jsonlite)
write_json(run[c(&quot;x&quot;,&quot;y&quot;)], &quot;mbo_res.json&quot;)</code></pre>
<p>Let’s assume we saved all of that above as an R-script under the name <a href="https://gist.github.com/jakob-r/6be022d49e135c7905fd4c097bc3d376"><code>runMBO.R</code> (actually it is available as a gist)</a>.</p>
<p>Then you can simply run it from the command line:</p>
<pre class="bash"><code>Rscript runMBO.R </code></pre>
<p>As an extra the script in the gist also contains a simple handler for command line arguments.
In this case you can define the number of optimization iterations and the maximal allowed time in seconds for the optimization.
You can also define the seed to make runs reproducible:</p>
<pre class="bash"><code>Rscript runMBO.R iters=20 time=10 seed=3</code></pre>
<p>If you want to build a more advanced command line interface you might want to have a <a href="https://www.slideshare.net/EdwindeJonge1/docopt-user2014">look</a> <a href="https://github.com/docopt/docopt.R">at</a> <a href="https://cran.r-project.org/package=docopt">docopt</a>.</p>
</div>
<div id="clean-up" class="section level3">
<h3>Clean up</h3>
<p>To clean up all the files generated by this script you can run:</p>
<pre class="r"><code>file.remove(&quot;result.txt&quot;)
file.remove(&quot;fun.sh&quot;)
file.remove(&quot;mbo_res.json&quot;)
output.files = list.files(pattern = &quot;output_\\d+_[0-9_.-]+\\.txt&quot;)
file.remove(output.files)</code></pre>
</div>
